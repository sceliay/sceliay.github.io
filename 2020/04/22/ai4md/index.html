<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>AI for Medicine | Sceliay's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AI for Medicine</h1><a id="logo" href="/.">Sceliay's Blog</a><p class="description">Welcome to my blog!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">AI for Medicine</h1><div class="post-meta">2020-04-22<span> | </span><span class="category"><a href="/categories/Machine-Learning/">Machine Learning</a></span></div><div class="post-content"><p>最近COURSERA上新开了一门课:<a href="https://www.coursera.org/specializations/ai-for-medicine" target="_blank" rel="noopener">AI for Medicine Specialization</a></p>
<h1 id="AI-for-Medical-Diagnosis"><a href="#AI-for-Medical-Diagnosis" class="headerlink" title="AI for Medical Diagnosis"></a><a href="https://www.coursera.org/learn/ai-for-medical-diagnosis/home/welcome" target="_blank" rel="noopener">AI for Medical Diagnosis</a></h1><ol>
<li><p><a href="https://arxiv.org/abs/1705.02315" target="_blank" rel="noopener">ChestX-ray8 dataset</a></p>
</li>
<li><p>Image Preprocessing in Keras</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># Import data generator from keras</span><br><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line"></span><br><span class="line"># Normalize images</span><br><span class="line">image_generator = ImageDataGenerator(</span><br><span class="line">    samplewise_center=True, #Set each sample mean to 0.</span><br><span class="line">    samplewise_std_normalization= True # Divide each input by its standard deviation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Flow from directory with specified batch size and target image size</span><br><span class="line">generator = image_generator.flow_from_dataframe(</span><br><span class="line">        dataframe=train_df,</span><br><span class="line">        directory=&quot;nih/images-small/&quot;,</span><br><span class="line">        x_col=&quot;Image&quot;, # features</span><br><span class="line">        y_col= [&apos;Mass&apos;], # labels</span><br><span class="line">        class_mode=&quot;raw&quot;, # &apos;Mass&apos; column should be in train_df</span><br><span class="line">        batch_size= 1, # images per batch</span><br><span class="line">        shuffle=False, # shuffle the rows or not</span><br><span class="line">        target_size=(320,320) # width and height of output image</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Plot a processed image</span><br><span class="line">sns.set_style(&quot;white&quot;)</span><br><span class="line">generated_image, label = generator.__getitem__(0)</span><br><span class="line">plt.imshow(generated_image[0], cmap=&apos;gray&apos;)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.title(&apos;Raw Chest X Ray Image&apos;)</span><br><span class="line">print(f&quot;The dimensions of the image are &#123;generated_image.shape[1]&#125; pixels width and &#123;generated_image.shape[2]&#125; pixels height&quot;)</span><br><span class="line">print(f&quot;The maximum pixel value is &#123;generated_image.max():.4f&#125; and the minimum is &#123;generated_image.min():.4f&#125;&quot;)</span><br><span class="line">print(f&quot;The mean value of the pixels is &#123;generated_image.mean():.4f&#125; and the standard deviation is &#123;generated_image.std():.4f&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># Include a histogram of the distribution of the pixels</span><br><span class="line">sns.set()</span><br><span class="line">plt.figure(figsize=(10, 7))</span><br><span class="line"></span><br><span class="line"># Plot histogram for original iamge</span><br><span class="line">sns.distplot(raw_image.ravel(), </span><br><span class="line">             label=f&apos;Original Image: mean &#123;np.mean(raw_image):.4f&#125; - Standard Deviation &#123;np.std(raw_image):.4f&#125; \n &apos;</span><br><span class="line">             f&apos;Min pixel value &#123;np.min(raw_image):.4&#125; - Max pixel value &#123;np.max(raw_image):.4&#125;&apos;,</span><br><span class="line">             color=&apos;blue&apos;, </span><br><span class="line">             kde=False)</span><br><span class="line"></span><br><span class="line"># Plot histogram for generated image</span><br><span class="line">sns.distplot(generated_image[0].ravel(), </span><br><span class="line">             label=f&apos;Generated Image: mean &#123;np.mean(generated_image[0]):.4f&#125; - Standard Deviation &#123;np.std(generated_image[0]):.4f&#125; \n&apos;</span><br><span class="line">             f&apos;Min pixel value &#123;np.min(generated_image[0]):.4&#125; - Max pixel value &#123;np.max(generated_image[0]):.4&#125;&apos;, </span><br><span class="line">             color=&apos;red&apos;, </span><br><span class="line">             kde=False)</span><br><span class="line"></span><br><span class="line"># Place legends</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(&apos;Distribution of Pixel Intensities in the Image&apos;)</span><br><span class="line">plt.xlabel(&apos;Pixel Intensity&apos;)</span><br><span class="line">plt.ylabel(&apos;# Pixel&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dense net</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Import Densenet from Keras</span><br><span class="line">from keras.applications.densenet import DenseNet121</span><br><span class="line">from keras.layers import Dense, GlobalAveragePooling2D</span><br><span class="line">from keras.models import Model</span><br><span class="line">from keras import backend as K</span><br><span class="line"></span><br><span class="line"># Create the base pre-trained model</span><br><span class="line">base_model = DenseNet121(weights=&apos;./nih/densenet.hdf5&apos;, include_top=False);</span><br><span class="line"></span><br><span class="line"># Print the model summary</span><br><span class="line">base_model.summary()</span><br><span class="line"></span><br><span class="line"># The number of output channels</span><br><span class="line">print(&quot;The output has 1024 channels&quot;)</span><br><span class="line">x = base_model.output</span><br><span class="line"></span><br><span class="line"># Add a global spatial average pooling layer</span><br><span class="line">x_pool = GlobalAveragePooling2D()(x)</span><br><span class="line"></span><br><span class="line"># Define a set of five class labels to use as an example</span><br><span class="line">labels = [&apos;Emphysema&apos;, </span><br><span class="line">          &apos;Hernia&apos;, </span><br><span class="line">          &apos;Mass&apos;, </span><br><span class="line">          &apos;Pneumonia&apos;,  </span><br><span class="line">          &apos;Edema&apos;]</span><br><span class="line">n_classes = len(labels)</span><br><span class="line">print(f&quot;In this example, you want your model to identify &#123;n_classes&#125; classes&quot;)</span><br><span class="line"></span><br><span class="line"># Add a logistic layer the same size as the number of classes you&apos;re trying to predict</span><br><span class="line">predictions = Dense(n_classes, activation=&quot;sigmoid&quot;)(x_pool)</span><br><span class="line">print(f&quot;Predictions have &#123;n_classes&#125; units, one for each class&quot;)</span><br><span class="line"></span><br><span class="line"># Create an updated model</span><br><span class="line">model = Model(inputs=base_model.input, outputs=predictions)</span><br><span class="line"></span><br><span class="line"># Compile the model</span><br><span class="line">model.compile(optimizer=&apos;adam&apos;,</span><br><span class="line">              loss=&apos;categorical_crossentropy&apos;)</span><br><span class="line"># (You&apos;ll customize the loss function in the assignment!)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Chest-X-Ray-Medical-Diagnosis-with-Deep-Learning"><a href="#Chest-X-Ray-Medical-Diagnosis-with-Deep-Learning" class="headerlink" title="Chest X-Ray Medical Diagnosis with Deep Learning"></a>Chest X-Ray Medical Diagnosis with Deep Learning</h1><ol>
<li><p>Import packages and functions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line">from keras.applications.densenet import DenseNet121</span><br><span class="line">from keras.layers import Dense, GlobalAveragePooling2D</span><br><span class="line">from keras.models import Model</span><br><span class="line">from keras import backend as K</span><br><span class="line"></span><br><span class="line">from keras.models import load_model</span><br><span class="line"></span><br><span class="line">import util</span><br></pre></td></tr></table></figure>
</li>
<li><p>Load the Datasets</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_df = pd.read_csv(&quot;nih/train-small.csv&quot;)</span><br><span class="line">valid_df = pd.read_csv(&quot;nih/valid-small.csv&quot;)</span><br><span class="line">test_df = pd.read_csv(&quot;nih/test.csv&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Preventing Data Leakage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># UNQ_C1 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)</span><br><span class="line">def check_for_leakage(df1, df2, patient_col):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Return True if there any patients are in both df1 and df2.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        df1 (dataframe): dataframe describing first dataset</span><br><span class="line">        df2 (dataframe): dataframe describing second dataset</span><br><span class="line">        patient_col (str): string name of column with patient IDs</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">        leakage (bool): True if there is leakage, otherwise False</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    ### START CODE HERE (REPLACE INSTANCES OF &apos;None&apos; with your code) ###</span><br><span class="line">    </span><br><span class="line">    df1_patients_unique = list(set(df1[patient_col].tolist()))</span><br><span class="line">    df2_patients_unique = list(set(df2[patient_col].tolist()))</span><br><span class="line">    </span><br><span class="line">    patients_in_both_groups = list(set(df1_patients_unique+df2_patients_unique))</span><br><span class="line"></span><br><span class="line">    # leakage contains true if there is patient overlap, otherwise false.</span><br><span class="line">    leakage = False # boolean (true if there is at least 1 patient in both groups)</span><br><span class="line">    if len(patients_in_both_groups)&lt;len(df1_patients_unique)+len(df2_patients_unique):</span><br><span class="line">        leakage = True</span><br><span class="line">    </span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line">    </span><br><span class="line">    return leakage</span><br></pre></td></tr></table></figure>
</li>
<li><p>Preparing Images</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">def get_train_generator(df, image_dir, x_col, y_cols, shuffle=True, batch_size=8, seed=1, target_w = 320, target_h = 320):</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Return generator for training set, normalizing using batch</span><br><span class="line">  statistics.</span><br><span class="line"></span><br><span class="line">  Args:</span><br><span class="line">    train_df (dataframe): dataframe specifying training data.</span><br><span class="line">    image_dir (str): directory where image files are held.</span><br><span class="line">    x_col (str): name of column in df that holds filenames.</span><br><span class="line">    y_cols (list): list of strings that hold y labels for images.</span><br><span class="line">    sample_size (int): size of sample to use for normalization statistics.</span><br><span class="line">    batch_size (int): images per batch to be fed into model during training.</span><br><span class="line">    seed (int): random seed.</span><br><span class="line">    target_w (int): final width of input images.</span><br><span class="line">    target_h (int): final height of input images.</span><br><span class="line">  </span><br><span class="line">  Returns:</span><br><span class="line">      train_generator (DataFrameIterator): iterator over training set</span><br><span class="line">  &quot;&quot;&quot;        </span><br><span class="line">  print(&quot;getting train generator...&quot;) </span><br><span class="line">  # normalize images</span><br><span class="line">  image_generator = ImageDataGenerator(</span><br><span class="line">      samplewise_center=True,</span><br><span class="line">      samplewise_std_normalization= True)</span><br><span class="line">  </span><br><span class="line">  # flow from directory with specified batch size</span><br><span class="line">  # and target image size</span><br><span class="line">  generator = image_generator.flow_from_dataframe(</span><br><span class="line">          dataframe=df,</span><br><span class="line">          directory=image_dir,</span><br><span class="line">          x_col=x_col,</span><br><span class="line">          y_col=y_cols,</span><br><span class="line">          class_mode=&quot;raw&quot;,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          shuffle=shuffle,</span><br><span class="line">          seed=seed,</span><br><span class="line">          target_size=(target_w,target_h))</span><br><span class="line">  </span><br><span class="line">  return generator</span><br><span class="line">  </span><br><span class="line">def get_test_and_valid_generator(valid_df, test_df, train_df, image_dir, x_col, y_cols, sample_size=100, batch_size=8, seed=1, target_w = 320, target_h = 320):</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Return generator for validation set and test test set using </span><br><span class="line">  normalization statistics from training set.</span><br><span class="line"></span><br><span class="line">  Args:</span><br><span class="line">    valid_df (dataframe): dataframe specifying validation data.</span><br><span class="line">    test_df (dataframe): dataframe specifying test data.</span><br><span class="line">    train_df (dataframe): dataframe specifying training data.</span><br><span class="line">    image_dir (str): directory where image files are held.</span><br><span class="line">    x_col (str): name of column in df that holds filenames.</span><br><span class="line">    y_cols (list): list of strings that hold y labels for images.</span><br><span class="line">    sample_size (int): size of sample to use for normalization statistics.</span><br><span class="line">    batch_size (int): images per batch to be fed into model during training.</span><br><span class="line">    seed (int): random seed.</span><br><span class="line">    target_w (int): final width of input images.</span><br><span class="line">    target_h (int): final height of input images.</span><br><span class="line">  </span><br><span class="line">  Returns:</span><br><span class="line">      test_generator (DataFrameIterator) and valid_generator: iterators over test set and validation set respectively</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  print(&quot;getting train and valid generators...&quot;)</span><br><span class="line">  # get generator to sample dataset</span><br><span class="line">  raw_train_generator = ImageDataGenerator().flow_from_dataframe(</span><br><span class="line">      dataframe=train_df, </span><br><span class="line">      directory=IMAGE_DIR, </span><br><span class="line">      x_col=&quot;Image&quot;, </span><br><span class="line">      y_col=labels, </span><br><span class="line">      class_mode=&quot;raw&quot;, </span><br><span class="line">      batch_size=sample_size, </span><br><span class="line">      shuffle=True, </span><br><span class="line">      target_size=(target_w, target_h))</span><br><span class="line">  </span><br><span class="line">  # get data sample</span><br><span class="line">  batch = raw_train_generator.next()</span><br><span class="line">  data_sample = batch[0]</span><br><span class="line"></span><br><span class="line">  # use sample to fit mean and std for test set generator</span><br><span class="line">  image_generator = ImageDataGenerator(</span><br><span class="line">      featurewise_center=True,</span><br><span class="line">      featurewise_std_normalization= True)</span><br><span class="line">  </span><br><span class="line">  # fit generator to sample from training data</span><br><span class="line">  image_generator.fit(data_sample)</span><br><span class="line"></span><br><span class="line">  # get test generator</span><br><span class="line">  valid_generator = image_generator.flow_from_dataframe(</span><br><span class="line">          dataframe=valid_df,</span><br><span class="line">          directory=image_dir,</span><br><span class="line">          x_col=x_col,</span><br><span class="line">          y_col=y_cols,</span><br><span class="line">          class_mode=&quot;raw&quot;,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          shuffle=False,</span><br><span class="line">          seed=seed,</span><br><span class="line">          target_size=(target_w,target_h))</span><br><span class="line"></span><br><span class="line">  test_generator = image_generator.flow_from_dataframe(</span><br><span class="line">          dataframe=test_df,</span><br><span class="line">          directory=image_dir,</span><br><span class="line">          x_col=x_col,</span><br><span class="line">          y_col=y_cols,</span><br><span class="line">          class_mode=&quot;raw&quot;,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          shuffle=False,</span><br><span class="line">          seed=seed,</span><br><span class="line">          target_size=(target_w,target_h))</span><br><span class="line">  return valid_generator, test_generator</span><br><span class="line"></span><br><span class="line">IMAGE_DIR = &quot;nih/images-small/&quot;</span><br><span class="line">train_generator = get_train_generator(train_df, IMAGE_DIR, &quot;Image&quot;, labels)</span><br><span class="line">valid_generator, test_generator= get_test_and_valid_generator(valid_df, test_df, train_df, IMAGE_DIR, &quot;Image&quot;, labels)</span><br><span class="line"></span><br><span class="line">x, y = train_generator.__getitem__(0)</span><br><span class="line">plt.imshow(x[0]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Model Development</p>
<ul>
<li><p>Addressing class imbalance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"># UNQ_C2 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)</span><br><span class="line">def compute_class_freqs(labels):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Compute positive and negative frequences for each class.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        labels (np.array): matrix of labels, size (num_examples, num_classes)</span><br><span class="line">    Returns:</span><br><span class="line">        positive_frequencies (np.array): array of positive frequences for each</span><br><span class="line">                                         class, size (num_classes)</span><br><span class="line">        negative_frequencies (np.array): array of negative frequences for each</span><br><span class="line">                                         class, size (num_classes)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ### START CODE HERE (REPLACE INSTANCES OF &apos;None&apos; with your code) ###</span><br><span class="line">    </span><br><span class="line">    # total number of patients (rows)</span><br><span class="line">    N = len(labels)</span><br><span class="line">    </span><br><span class="line">    positive_frequencies = sum(labels)/N</span><br><span class="line">    negative_frequencies = 1-positive_frequencies</span><br><span class="line"></span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line">    return positive_frequencies, negative_frequencies</span><br><span class="line"></span><br><span class="line">freq_pos, freq_neg = compute_class_freqs(train_generator.labels)</span><br><span class="line">pos_weights = freq_neg</span><br><span class="line">neg_weights = freq_pos</span><br><span class="line">pos_contribution = freq_pos * pos_weights </span><br><span class="line">neg_contribution = freq_neg * neg_weights</span><br><span class="line"></span><br><span class="line"># UNQ_C3 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)</span><br><span class="line">def get_weighted_loss(pos_weights, neg_weights, epsilon=1e-7):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Return weighted loss function given negative weights and positive weights.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">      pos_weights (np.array): array of positive weights for each class, size (num_classes)</span><br><span class="line">      neg_weights (np.array): array of negative weights for each class, size (num_classes)</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">      weighted_loss (function): weighted loss function</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def weighted_loss(y_true, y_pred):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Return weighted loss value. </span><br><span class="line"></span><br><span class="line">        Args:</span><br><span class="line">            y_true (Tensor): Tensor of true labels, size is (num_examples, num_classes)</span><br><span class="line">            y_pred (Tensor): Tensor of predicted labels, size is (num_examples, num_classes)</span><br><span class="line">        Returns:</span><br><span class="line">            loss (Tensor): overall scalar loss summed across all classes</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # initialize loss to zero</span><br><span class="line">        loss = 0.0</span><br><span class="line">        </span><br><span class="line">        ### START CODE HERE (REPLACE INSTANCES OF &apos;None&apos; with your code) ###</span><br><span class="line"></span><br><span class="line">        for i in range(len(pos_weights)):</span><br><span class="line">            # for each class, add average weighted loss for that class </span><br><span class="line">            loss += K.mean(-(pos_weights[i]*y_true[:,i]*K.log(y_pred[:,i]+epsilon)+neg_weights[i]*(1-y_true[:,i])*K.log(1-y_pred[:,i]+epsilon)))</span><br><span class="line">        return loss</span><br><span class="line">    </span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line">    return weighted_loss</span><br></pre></td></tr></table></figure>
</li>
<li><p>DenseNet121</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># create the base pre-trained model</span><br><span class="line">base_model = DenseNet121(weights=&apos;./nih/densenet.hdf5&apos;, include_top=False)</span><br><span class="line"></span><br><span class="line">x = base_model.output</span><br><span class="line"></span><br><span class="line"># add a global spatial average pooling layer</span><br><span class="line">x = GlobalAveragePooling2D()(x)</span><br><span class="line"></span><br><span class="line"># and a logistic layer</span><br><span class="line">predictions = Dense(len(labels), activation=&quot;sigmoid&quot;)(x)</span><br><span class="line"></span><br><span class="line">model = Model(inputs=base_model.input, outputs=predictions)</span><br><span class="line">model.compile(optimizer=&apos;adam&apos;, loss=get_weighted_loss(pos_weights, neg_weights))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Training</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit_generator(train_generator, </span><br><span class="line">                              validation_data=valid_generator,</span><br><span class="line">                              steps_per_epoch=100, </span><br><span class="line">                              validation_steps=25, </span><br><span class="line">                              epochs = 3)</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[&apos;loss&apos;])</span><br><span class="line">plt.ylabel(&quot;loss&quot;)</span><br><span class="line">plt.xlabel(&quot;epoch&quot;)</span><br><span class="line">plt.title(&quot;Training Loss Curve&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>model.load_weights(&quot;./nih/pretrained_model.h5&quot;)</code></li>
</ul>
</li>
<li>Prediction and Evaluation<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predicted_vals = model.predict_generator(test_generator, steps = len(test_generator))</span><br><span class="line">auc_rocs = util.get_roc_curve(labels, predicted_vals, test_generator)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="ACCURACY"><a href="#ACCURACY" class="headerlink" title="ACCURACY"></a>ACCURACY</h1><ol>
<li><code>Accuracy = P(+|disease)P(disease)+P(-|normal)P(normal)</code><ul>
<li>P(+|disease): Sensitivity(true positive rate)</li>
<li>P(-|normal): Specificity(true negtive rate)</li>
<li>P(disease): Prevalence</li>
<li><code>Accuracy = Sensitivity*Prevalence+Specificity*(1-Prevalence)</code></li>
</ul>
</li>
<li>PPV &amp; NPV<ul>
<li>PPV: P(disease|+)</li>
<li>NPV: P(normal|-)</li>
</ul>
</li>
<li><p>confusion matrix:</p>
<pre><code>            +                -
</code></pre><p>disease   true positive     false negative    → #(+ and disease)/#disease = sensitvity<br>normal    false positive    true negative     → #(- and normal)/#normal = specificity</p>
<pre><code>           ↓                  ↓
</code></pre><p>#(+ and disease)/#(+) = PPV     #(- and normal)/#(-) = NPV</p>
<p>sensitivity = tp/(tp+fn)<br>specificity = tn/(fp+tn)<br>ppv = tp/(tp+fp)<br>npv = tn/(fn+tn)</p>
</li>
<li><p>probability</p>
<ul>
<li>ppv = p(pos|pos_p) = p(pos_p|pos)×p(pos)/p(pos_p)<ul>
<li>sensitivity = p(pos_p|pos)</li>
<li>prevalence = p(pos)<ul>
<li>p(pos_p) = truePos+falsePos <ul>
<li>truePos = p(pos_p|pos)×p(pos) = sensitivity×prevalence</li>
<li>falsePos = p(pos_p|neg)×p(neg)<ul>
<li>p(pos_p|neg) = 1-specificity</li>
<li>p(neg) = 1-prevalence</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ppv = sentsitivity×prevalence/(sensitivity×prevalence+(1-specificity)×(1-prevalence))</li>
</ul>
</li>
</ol>
</div><div class="tags"><a href="/tags/Machine Learning"><i class="fa fa-tag">Machine Learning</i></a></div><div class="post-nav"><a class="pre" href="/2020/04/23/matplotlib/">Matplotlib</a><a class="next" href="/2020/04/01/ml/">Machine Learning</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '179d25b3988d41a8a145',
  clientSecret: '7812569c157b17fe879957b54b477810952b77c1',
  repo: 'sceliay.github.io/',
  owner: 'sceliay',
  admin: ['sceliay'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://github.com/sceliay"></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/head.jpg"></a><p>当你凝视深渊的时候，深渊也在凝视着你。</p><a class="info-icon" href="https://twitter.com/yren_zj" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="yren@zhejianglab.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/sceliay" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Keras/" style="font-size: 15px;">Keras</a> <a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/Embedding/" style="font-size: 15px;">Embedding</a> <a href="/tags/Theano/" style="font-size: 15px;">Theano</a> <a href="/tags/Anaconda/" style="font-size: 15px;">Anaconda</a> <a href="/tags/tmux/" style="font-size: 15px;">tmux</a> <a href="/tags/Jupyter/" style="font-size: 15px;">Jupyter</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/EHR/" style="font-size: 15px;">EHR</a> <a href="/tags/Pandas/" style="font-size: 15px;">Pandas</a> <a href="/tags/Pytorch/" style="font-size: 15px;">Pytorch</a> <a href="/tags/Data-Structure/" style="font-size: 15px;">Data Structure</a> <a href="/tags/quality/" style="font-size: 15px;">quality</a> <a href="/tags/Notes/" style="font-size: 15px;">Notes</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/09/26/med-bert/">Med BERT</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/18/mldl/">MLDL</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/12/cat/">cat</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/13/keras-1/">Keras 学习笔记(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/20/BERT/">BERT</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ai4md2/">AI for Medicine(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/26/offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/23/matplotlib/">Matplotlib</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/ai4md/">AI for Medicine</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/ml/">Machine Learning</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Sceliay's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>